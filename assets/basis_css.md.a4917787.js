import{_ as i,o as l,c as a,S as e}from"./chunks/framework.f15d8f8c.js";const f=JSON.parse('{"title":"CSS","description":"","frontmatter":{},"headers":[],"relativePath":"basis/css.md","filePath":"basis/css.md"}'),r={name:"basis/css.md"},t=e('<h1 id="css" tabindex="-1">CSS <a class="header-anchor" href="#css" aria-label="Permalink to &quot;CSS&quot;">​</a></h1><h2 id="盒模型介绍" tabindex="-1">盒模型介绍 <a class="header-anchor" href="#盒模型介绍" aria-label="Permalink to &quot;盒模型介绍&quot;">​</a></h2><p>盒模型是 CSS 中一个非常重要的概念，它定义了一个 HTML 元素在页面中所占据的空间。盒模型由四个部分组成：内容区域（content）、内边距（padding）、边框（border）和外边距（margin）。这四个部分相互嵌套，形成了一个矩形的盒子，用来包裹 HTML 元素</p><p>盒模型的大小计算方式可以分为两种：标准盒模型和 IE 盒模型（怪异盒模型）。标准盒模型的大小是指内容区域的大小，不包括内边距和边框；而 IE 盒模型的大小是指内容区域、内边距和边框的总和。在 CSS 中，可以通过设置 box-sizing 属性来指定使用哪种盒模型</p><ul><li>标准盒模型：只包含 content</li><li>IE（替代）盒模型：content + padding + border</li></ul><p>可以通过 box-sizing 来改变元素的盒模型：</p><ul><li><strong>box-sizing: content-box</strong> ：标准盒模型（默认值）</li><li><strong>box-sizing: border-box</strong> ：IE（替代）盒模型</li></ul><h2 id="bfc-理解和应用" tabindex="-1">BFC 理解和应用 <a class="header-anchor" href="#bfc-理解和应用" aria-label="Permalink to &quot;BFC 理解和应用&quot;">​</a></h2><p><strong>BFC（Block Formatting Context）</strong> 是 CSS 中的一个布局概念，它是一个独立的渲染区域（容器），其中的元素按照一定的规则进行布局和定位。BFC 可以解决许多布局问题，如 margin 重叠、清除浮动等</p><h3 id="bfc-的触发条件" tabindex="-1">BFC 的触发条件： <a class="header-anchor" href="#bfc-的触发条件" aria-label="Permalink to &quot;BFC 的触发条件：&quot;">​</a></h3><ul><li>根元素 html</li><li>float 的值不是 none</li><li>position 的值不是 static 或者 relative</li><li>overflow 的值不是 visible</li><li>display 的值是 inline-block,table-cell,flex,table-caption 或者 inline-flex</li></ul><h3 id="bfc-的特性" tabindex="-1">BFC 的特性 <a class="header-anchor" href="#bfc-的特性" aria-label="Permalink to &quot;BFC 的特性&quot;">​</a></h3><ul><li>内部的 Box 会在垂直方向上一个接一个放置。</li><li>Box 垂直方向的距离由 margin 决定，属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠。</li><li>每个元素的 margin box 的左边，与包含块 border box 的左边相接触。</li><li>BFC 的区域不会与 float box 重叠。</li><li>BFC 是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。</li><li>计算 BFC 的高度时，浮动元素也会参与计算。</li></ul><h3 id="bfc-的作用" tabindex="-1">BFC 的作用： <a class="header-anchor" href="#bfc-的作用" aria-label="Permalink to &quot;BFC 的作用：&quot;">​</a></h3><ul><li><strong>清除浮动：</strong> 当一个元素的子元素都是浮动元素时，父元素会发生高度塌陷，无法正常包裹子元素。在父元素上创建 BFC 可以清除浮动，使父元素能够正常包裹子元素。</li><li><strong>防止外边距重叠：</strong> 在普通流中，相邻的两个元素的垂直外边距可能会发生重叠。在 BFC 中，垂直外边距会被限制在各自的 BFC 内部，从而避免了外边距重叠的问题。</li><li><strong>控制元素的定位和布局：</strong> 在 BFC 中，可以使用一些 CSS 属性来控制元素的定位和布局，如 float、position、display 等。</li></ul><h2 id="margin-纵向重叠问题" tabindex="-1">margin 纵向重叠问题 <a class="header-anchor" href="#margin-纵向重叠问题" aria-label="Permalink to &quot;margin 纵向重叠问题&quot;">​</a></h2><p>margin 重叠（又称 margin 塌陷）是指文档流内，块级元素与块级元素垂直方向上的 margin 合并（塌陷）为单个 margin，且只发生在垂直方向。这种情况下，相邻兄弟元素间的外边距会按照一定规则合并，而不是简单相加</p><h3 id="解决-margin-重叠的方法" tabindex="-1">解决 margin 重叠的方法: <a class="header-anchor" href="#解决-margin-重叠的方法" aria-label="Permalink to &quot;解决 margin 重叠的方法:&quot;">​</a></h3><ul><li><strong>使用 BFC：</strong> 由于 BFC 可以隔离元素，防止外边距重叠，因此可以通过触发 BFC 来解决 margin 重叠问题。例如，可以使其中一个元素的父元素触发 BFC，从而使该元素与相邻元素不属于同一个 BFC，从而避免外边距重叠。</li><li><strong>设置边框或内边距：</strong> 为父元素或相邻元素设置边框（border）或内边距（padding），可以阻止外边距重叠。</li><li><strong>使用 Flex 布局：</strong> 在 Flex 布局中，子元素的 margin 不会重叠。</li></ul><h2 id="css-选择器和优先级" tabindex="-1">css 选择器和优先级 <a class="header-anchor" href="#css-选择器和优先级" aria-label="Permalink to &quot;css 选择器和优先级&quot;">​</a></h2><p>CSS 选择器用于选择 HTML 文档中的元素，以便为其应用样式。选择器的优先级决定了当多个样式规则应用于同一个元素时，哪个规则将最终生效</p><h3 id="选择器类型及优先级" tabindex="-1">选择器类型及优先级： <a class="header-anchor" href="#选择器类型及优先级" aria-label="Permalink to &quot;选择器类型及优先级：&quot;">​</a></h3><ul><li>ID 选择器（#id）：每个 ID 选择器计为 100。</li><li>类选择器（.class）、属性选择器（[attr]）和伪类选择器（:hover, :focus 等）：每个此类选择器计为 10。</li><li>元素选择器（p, div, span 等）和伪元素选择器（::before, ::after 等）：每个元素或伪元素选择器计为 1。</li><li>行内样式（通过 HTML 元素的 style 属性直接定义的样式）具有最高的优先级，除非遇到!important 规则。</li><li>!important 规则：当一个声明后面跟有!important 时</li></ul><h2 id="重排-reflow-和重绘-repaint-的理解" tabindex="-1">重排（reflow）和重绘（repaint）的理解 <a class="header-anchor" href="#重排-reflow-和重绘-repaint-的理解" aria-label="Permalink to &quot;重排（reflow）和重绘（repaint）的理解&quot;">​</a></h2><p>重排（Reflow）和重绘（Repaint）是浏览器在渲染页面时的重要概念，它们分别涉及页面布局的计算和元素外观的更新。以下是对这两个概念的理解：</p><h3 id="重排-reflow" tabindex="-1">重排（Reflow） <a class="header-anchor" href="#重排-reflow" aria-label="Permalink to &quot;重排（Reflow）&quot;">​</a></h3><p><strong>定义：</strong></p><p>重排，也称为回流或重构，是指浏览器在渲染页面时，根据 DOM 结构和 CSS 样式计算元素的布局和几何属性的过程。当页面中的元素发生变化（如添加、删除或修改元素），或者浏览器窗口大小改变时，都会触发重排操作。</p><p><strong>触发条件：</strong></p><ul><li>页面渲染初始化（无法避免）</li><li>添加或删除可见的 DOM 元素</li><li>元素位置的改变，或者使用动画</li><li>元素尺寸的改变，包括大小、外边距、边框等</li><li>浏览器窗口尺寸的变化（resize 事件发生时）</li><li>填充内容的改变，比如文本的改变或图片大小改变而引起的计算值宽度和高度的改变</li><li>读取某些元素属性，如 offsetLeft/Top/Height/Width, clientTop/Left/Width/Height, scrollTop/Left/Width/Height, width/height, getComputedStyle(), currentStyle(IE)等</li></ul><p><strong>性能影响：</strong></p><p>重排是一个比较耗费性能的操作，因为它会影响到整个页面的布局。在重排过程中，浏览器需要重新计算受影响的元素及其子元素的位置和大小，这可能导致整个页面的重新布局。</p><h3 id="重绘-repaint" tabindex="-1">重绘（Repaint） <a class="header-anchor" href="#重绘-repaint" aria-label="Permalink to &quot;重绘（Repaint）&quot;">​</a></h3><p><strong>定义：</strong></p><p>重绘是指浏览器进行渲染时，根据计算好的布局信息，将元素绘制成像素的过程。当元素的外观属性（如颜色、背景、边框等）发生变化时，会触发重绘操作。</p><p><strong>触发条件：</strong></p><ul><li>改变元素外观属性，如颜色、背景色、边框样式等</li></ul><p><strong>性能影响：</strong></p><p>与重排不同，重绘只涉及到元素外观的更改，而不会影响到布局。因此，重绘的性能开销相对较小。但是，如果页面中有大量的元素需要重绘，或者重绘操作频繁发生，仍然会对页面性能产生不利影响。</p><h3 id="重排与重绘的关系" tabindex="-1">重排与重绘的关系 <a class="header-anchor" href="#重排与重绘的关系" aria-label="Permalink to &quot;重排与重绘的关系&quot;">​</a></h3><ul><li>重排一定会引发重绘，因为元素的布局变化后，其外观也需要重新绘制以反映新的布局。</li><li>但重绘不一定会引发重排，只有当元素的外观变化不会影响到布局时，才会只触发重绘而不触发重排。</li></ul><h3 id="如何减少重排和重绘" tabindex="-1">如何减少重排和重绘 <a class="header-anchor" href="#如何减少重排和重绘" aria-label="Permalink to &quot;如何减少重排和重绘&quot;">​</a></h3><p>为了减少重排和重绘对页面性能的影响，可以采取以下策略：</p><ul><li>避免频繁操作 DOM：尽量通过修改 CSS 类名来批量修改样式，而不是直接操作 DOM 元素的样式属性。</li><li>使用文档片段（DocumentFragment）：在需要插入大量节点时，可以先将这些节点添加到文档片段中，然后再把整个文档片段添加到文档中。这样可以减少多次插入节点引起的重排。</li><li>避免频繁读取会引发重排/重绘的属性：如果确实需要多次使用这些属性的值，可以将其缓存到变量中。</li><li>使用 CSS 动画和过渡：在需要实现动画效果时，使用 CSS 动画和过渡，而不是 JavaScript 来操作元素样式。CSS 动画可以利用硬件加速，提高渲染性能。</li><li>使用高效的 CSS 布局技术：如 Flexbox 和 Grid 布局，它们可以减少对元素位置的频繁调整，从而减少重排。</li></ul><p>综上所述，重排和重绘是浏览器渲染页面时的重要过程，它们对页面性能有着重要影响。通过优化 DOM 操作、使用文档片段、避免频繁读取布局属性以及采用高效的 CSS 布局和动画技术，可以有效地减少重排和重绘的次数，提高页面性能。</p><h2 id="flex-布局" tabindex="-1">Flex 布局 <a class="header-anchor" href="#flex-布局" aria-label="Permalink to &quot;Flex 布局&quot;">​</a></h2><h3 id="容器的属性" tabindex="-1">容器的属性 <a class="header-anchor" href="#容器的属性" aria-label="Permalink to &quot;容器的属性&quot;">​</a></h3><ul><li><strong>flex-direction</strong>： 属性决定主轴的方向（即项目的排列方向） <ul><li>row（默认值）：主轴为水平方向，起点在左端。</li><li>row-reverse：主轴为水平方向，起点在右端。</li><li>column：主轴为垂直方向，起点在上沿。</li><li>column-reverse：主轴为垂直方向，起点在下沿。</li></ul></li><li><strong>flex-wrap</strong>：属性定义，如果一条轴线排不下，如何换行 <ul><li>nowrap（默认）：不换行。</li><li>wrap：换行，第一行在上方。</li><li>wrap-reverse：换行，第一行在下方。</li></ul></li><li><strong>flex-flow</strong>：属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap。</li><li><strong>justify-content</strong>：定义了项目在主轴上的对齐方式 <ul><li>flex-start（默认值）：左对齐</li><li>flex-end：右对齐</li><li>center： 居中</li><li>space-between：两端对齐，项目之间的间隔都相等。</li><li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ul></li><li><strong>align-items</strong>：定义项目在交叉轴上如何对齐。 <ul><li>flex-start：交叉轴的起点对齐。</li><li>flex-end：交叉轴的终点对齐。</li><li>center：交叉轴的中点对齐。</li><li>baseline: 项目的第一行文字的基线对齐。</li><li>stretch（默认值）：如果项目未设置高度或设为 auto，将占满整个容器的高度。</li></ul></li><li><strong>align-content</strong>：定义了多根轴线的对齐方式 <ul><li>flex-start：与交叉轴的起点对齐。</li><li>flex-end：与交叉轴的终点对齐。</li><li>center：与交叉轴的中点对齐。</li><li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li><li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li>stretch（默认值）：轴线占满整个交叉轴。</li></ul></li></ul><h3 id="项目的属性" tabindex="-1">项目的属性 <a class="header-anchor" href="#项目的属性" aria-label="Permalink to &quot;项目的属性&quot;">​</a></h3><ul><li><strong>order</strong>：定义项目的排列顺序。数值越小，排列越靠前，默认为 0</li><li><strong>flex-grow</strong>：定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大。</li><li><strong>flex-shrink</strong>：定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。</li><li><strong>flex-basis</strong>：定义了在分配多余空间之前，项目占据的主轴空间（main size）</li><li><strong>flex</strong>：属性是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto。后两个属性可选</li><li><strong>align-self</strong>：允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性</li></ul><h2 id="line-height-和-margin-百分比继承" tabindex="-1">line-height 和 margin 百分比继承 <a class="header-anchor" href="#line-height-和-margin-百分比继承" aria-label="Permalink to &quot;line-height 和 margin 百分比继承&quot;">​</a></h2><ul><li>父元素的 line-height 写了百分比，比如 200%，则子元素 line-height 继承的是父元素 font-size * 200% 计算出来的值</li><li>子元素的 margin 写了百分比，比如 margin：50%，则实际 margin 为<code>父级的 width*50%</code></li></ul>',52),n=[t];function o(s,h,c,g,d,u){return l(),a("div",null,n)}const b=i(r,[["render",o]]);export{f as __pageData,b as default};
