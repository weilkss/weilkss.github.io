import{_ as e,o as s,c as a,X as o}from"./chunks/framework.6e839c56.js";const h=JSON.parse('{"title":"Websocket","description":"","frontmatter":{},"headers":[],"relativePath":"advanced/websocket.md","filePath":"advanced/websocket.md"}'),l={name:"advanced/websocket.md"},t=o(`<h1 id="websocket" tabindex="-1">Websocket <a class="header-anchor" href="#websocket" aria-label="Permalink to &quot;Websocket&quot;">​</a></h1><h2 id="websocket-是什么" tabindex="-1">WebSocket 是什么 <a class="header-anchor" href="#websocket-是什么" aria-label="Permalink to &quot;WebSocket 是什么&quot;">​</a></h2><p>WebSocket 是一种网络通信协议。那么就有一个问题了：已经有了 HTTP 协议，为什么还需要 WebSocket？ 因为 HTTP 协议有一个缺陷：通信只能由客户端发起,做不到服务器主动向客户端推送信息。 HTTP 协议的这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用“轮询”：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。轮询的效率低，非常浪费资源。因此，大佬们一直在思考，有没有更好的方法。WebSocket 就是这样出现的。</p><blockquote><p>有基于 HTTP 实现的 EventSource 可以做到服务器向客服端主动发起消息</p></blockquote><h2 id="websocket-特点" tabindex="-1">WebSocket 特点 <a class="header-anchor" href="#websocket-特点" aria-label="Permalink to &quot;WebSocket 特点&quot;">​</a></h2><blockquote><p>WebSocket 协议在 2008 年诞生，2011 年成为国际标准。所有浏览器都已经支持了。</p></blockquote><p>它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。 WebSocket 允许服务器端与客户端进行全双工的通信。</p><p><strong>其他的一些特点：</strong></p><ul><li>建立在 TCP 协议之上，服务器端的实现比较容易。</li><li>与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</li><li>数据格式比较轻量，性能开销小，通信高效。</li><li>可以发送文本，也可以发送二进制数据。</li><li>没有同源限制，客户端可以与任意服务器通信，完全可以取代 Ajax。</li><li>协议标识符是 ws（如果加密，则为 wss，对应 HTTPS 协议），服务器网址就是 URL。</li></ul><h2 id="websocket-握手" tabindex="-1">WebSocket 握手 <a class="header-anchor" href="#websocket-握手" aria-label="Permalink to &quot;WebSocket 握手&quot;">​</a></h2><p>WebSocket 也要有一个握手过程，然后才能正式收发数据。</p><p><strong>客户端发送数据格式如下：</strong></p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">GET /chat HTTP/</span><span style="color:#F78C6C;">1.1</span></span>
<span class="line"><span style="color:#A6ACCD;">Host: server.example.com</span></span>
<span class="line"><span style="color:#A6ACCD;">Upgrade: websocket</span></span>
<span class="line"><span style="color:#A6ACCD;">Connection: Upgrade</span></span>
<span class="line"><span style="color:#A6ACCD;">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub</span><span style="color:#F78C6C;">25</span><span style="color:#A6ACCD;">jZQ==</span></span>
<span class="line"><span style="color:#A6ACCD;">Origin: http:</span><span style="color:#676E95;font-style:italic;">//example.com</span></span>
<span class="line"><span style="color:#A6ACCD;">Sec-WebSocket-Protocol: chat, superchat</span></span>
<span class="line"><span style="color:#A6ACCD;">Sec-WebSocket-Version: </span><span style="color:#F78C6C;">13</span></span></code></pre></div><ul><li>Connection：必须设置 Upgrade，表示客户端希望连接升级</li><li>Upgrade：必须设置 Websocket，表示希望升级到 Websocket 协议</li><li>Sec-WebSocket-Key：客户端发送的一个 base64 编码的密文，用于简单的认证秘钥。要求服务端必须返回一个对应加密的“Sec-WebSocket-Accept 应答，否则客户端会抛出错误，并关闭连接</li><li>Sec-WebSocket-Version ：表示支持的 Websocket 版本</li></ul><p><strong>服务端返回的数据格式：</strong></p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">HTTP/</span><span style="color:#F78C6C;">1.1</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">101</span><span style="color:#A6ACCD;"> Switching Protocols</span></span>
<span class="line"><span style="color:#A6ACCD;">Upgrade: websocket</span></span>
<span class="line"><span style="color:#A6ACCD;">Connection: Upgrade</span></span>
<span class="line"><span style="color:#A6ACCD;">Sec-WebSocket-Accept: s</span><span style="color:#F78C6C;">3</span><span style="color:#A6ACCD;">pPLMBiTxaQ</span><span style="color:#F78C6C;">9</span><span style="color:#A6ACCD;">kYGzzhZRbK+xOo=Sec-WebSocket-Protocol: chat</span></span></code></pre></div><ul><li>HTTP/1.1 101 Switching Protocols：表示服务端接受 WebSocket 协议的客户端连接</li><li>Sec-WebSocket-Accep：验证客户端请求报文，同样也是为了防止误连接。具体做法是把请求头里“Sec-WebSocket-Key”的值，加上一个专用的 UUID，再计算摘要</li></ul><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>WebSocket 是一种基于 TCP 的网络通信协议。 优点如下：</p><ul><li>较少的控制开销：数据包头部协议较小，不同于 http 每次请求需要携带完整的头部</li><li>更强的实时性：相对于 HTTP 请求需要等待客户端发起请求服务端才能响应，延迟明显更少</li><li>保持创连接状态：创建通信后，可省略状态信息，不同于 HTTP 每次请求需要携带身份验证</li><li>更好的二进制支持：定义了二进制帧，更好处理二进制内容</li><li>支持扩展：用户可以扩展 websocket 协议、实现部分自定义的子协议</li><li>更好的压缩效果：Websocket 在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率</li></ul>`,20),n=[t];function c(p,i,r,b,k,C){return s(),a("div",null,n)}const S=e(l,[["render",c]]);export{h as __pageData,S as default};
