import{_ as t,o as e,c as n,X as d}from"./chunks/framework.6e839c56.js";const r="/assets/image.4a04b4e2.png",b=JSON.parse('{"title":"算法","description":"","frontmatter":{},"headers":[],"relativePath":"advanced/sort/introduce.md","filePath":"advanced/sort/introduce.md"}'),a={name:"advanced/sort/introduce.md"},s=d('<h1 id="算法" tabindex="-1">算法 <a class="header-anchor" href="#算法" aria-label="Permalink to &quot;算法&quot;">​</a></h1><h2 id="算法概述" tabindex="-1">算法概述 <a class="header-anchor" href="#算法概述" aria-label="Permalink to &quot;算法概述&quot;">​</a></h2><p>十种常见排序算法可以分为两大类：</p><p><strong>非线性时间比较类排序：</strong> 通过比较来决定元素间的相对次序，由于其时间复杂度不能突破 O(nlogn)，因此称为非线性时间比较类排序。</p><p><strong>线性时间非比较类排序：</strong> 不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。</p><p><img src="'+r+'" alt="alt text"></p><h2 id="算法复杂度" tabindex="-1">算法复杂度 <a class="header-anchor" href="#算法复杂度" aria-label="Permalink to &quot;算法复杂度&quot;">​</a></h2><table><thead><tr><th style="text-align:center;">排序</th><th style="text-align:center;">时间复杂度（平均）</th><th style="text-align:center;">时间复杂度（最坏）</th><th>时间复杂度（最好）</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td style="text-align:center;"><strong>插入排序</strong></td><td style="text-align:center;">0(n^2)</td><td style="text-align:center;">0(n^2)</td><td>0(n)</td><td>0(1)</td><td>稳定</td></tr><tr><td style="text-align:center;"><strong>希尔排序</strong></td><td style="text-align:center;">0(n^1.3)</td><td style="text-align:center;">0(n^2)</td><td>0(n)</td><td>0(1)</td><td>不稳定</td></tr><tr><td style="text-align:center;"><strong>选择排序</strong></td><td style="text-align:center;">0(n^2)</td><td style="text-align:center;">0(n^2)</td><td>0(n^2)</td><td>0(1)</td><td>不稳定</td></tr><tr><td style="text-align:center;"><strong>堆排序</strong></td><td style="text-align:center;">O(nlog₂n)</td><td style="text-align:center;">O(nlog₂n)</td><td>O(nlog₂n)</td><td>0(1)</td><td>不稳定</td></tr><tr><td style="text-align:center;"><strong>冒泡排序</strong></td><td style="text-align:center;">0(n^2)</td><td style="text-align:center;">0(n^2)</td><td>0(n)</td><td>0(1)</td><td>稳定</td></tr><tr><td style="text-align:center;"><strong>快速排序</strong></td><td style="text-align:center;">O(nlog₂n)</td><td style="text-align:center;">0(n^2)</td><td>O(nlog₂n)</td><td>O(nlog₂n)</td><td>不稳定</td></tr><tr><td style="text-align:center;"><strong>归并排序</strong></td><td style="text-align:center;">O(nlog₂n)</td><td style="text-align:center;">O(nlog₂n)</td><td>O(nlog₂n)</td><td>0(n)</td><td>稳定</td></tr><tr><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td></td><td></td><td></td></tr><tr><td style="text-align:center;"><strong>计数排序</strong></td><td style="text-align:center;">0(n+k)</td><td style="text-align:center;">0(n+k)</td><td>0(n+k)</td><td>0(n+k)</td><td>稳定</td></tr><tr><td style="text-align:center;"><strong>桶排序</strong></td><td style="text-align:center;">0(n+k)</td><td style="text-align:center;">0(n^2)</td><td>0(n^2)</td><td>0(n+k)</td><td>稳定</td></tr><tr><td style="text-align:center;"><strong>基数排序</strong></td><td style="text-align:center;">0(n+k)</td><td style="text-align:center;">0(n+k)</td><td>0(n*k)</td><td>0(n+k)</td><td>稳定</td></tr></tbody></table><h2 id="相关概念" tabindex="-1">相关概念 <a class="header-anchor" href="#相关概念" aria-label="Permalink to &quot;相关概念&quot;">​</a></h2><p><strong>稳定：</strong> 如果 a 原本在 b 前面，而 a=b，排序之后 a 仍然在 b 的前面。</p><p><strong>不稳定：</strong> 如果 a 原本在 b 的前面，而 a=b，排序之后 a 可能会出现在 b 的后面。</p><p><strong>时间复杂度：</strong> 对排序数据的总的操作次数。反映当 n 变化时，操作次数呈现什么规律。</p><p><strong>空间复杂度：</strong> 是指算法在计算机内执行时所需存储空间的度量，它也是数据规模 n 的函数。</p><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MDA2MTI1MA==&amp;mid=2649106615&amp;idx=2&amp;sn=664f54223b7be179f36d5e547b2d205e&amp;chksm=be580f1a892f860cab5f3e7a22fe68478a103441f4c6921f0893a8eacb52fde3f9643bd7c837&amp;scene=27" target="_blank" rel="noreferrer">https://mp.weixin.qq.com/s?__biz=MjM5MDA2MTI1MA==&amp;mid=2649106615&amp;idx=2&amp;sn=664f54223b7be179f36d5e547b2d205e&amp;chksm=be580f1a892f860cab5f3e7a22fe68478a103441f4c6921f0893a8eacb52fde3f9643bd7c837&amp;scene=27</a></p>',14),l=[s];function o(c,g,i,x,h,p){return e(),n("div",null,l)}const f=t(a,[["render",o]]);export{b as __pageData,f as default};
